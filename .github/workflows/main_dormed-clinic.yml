name: Build and deploy Dormed Clinic app from local self-hosted runner

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: self-hosted   # This will run on your local machine

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Create Python virtual environment
        # Create the venv in the root of the repository.
        run: |
          python -m venv venv

      - name: Install Python dependencies
        # Activate the venv from the root and install requirements.txt (which is also in the root).
        run: |
          source venv/bin/activate
          pip install -r requirements.txt

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Set up Frontend .env (for React build)
        # Create the .env file in the frontend directory from a GitHub secret.
        # This makes environment variables available during the React build process.
        # Ensure your React environment variables are prefixed with REACT_APP_ (e.g., REACT_APP_API_URL).
        run: |
          echo "${{ secrets.FRONTEND_ENV_VARS }}" > frontend/.env
          # For security, you might want to remove this file after the build if it contains very sensitive info
          # but usually, the compiled JS is what contains the embedded vars.

      - name: Build React frontend
        # Navigate into the 'frontend' directory for npm commands.
        run: |
          cd frontend
          npm install
          npm run build

      - name: Prepare deployment package
        # Create the tarball from the parent directory to avoid "file changed" errors.
        # This will archive the 'dormed' directory itself, excluding specified folders.
        run: |
          cd .. # Move up one level to the _work directory
          tar --exclude=dormed/venv \
              --exclude=dormed/node_modules \
              --exclude=dormed/frontend/node_modules \
              -czf dormed-deploy-package.tar.gz dormed/
          # Move the created tarball back into the original working directory
          mv dormed-deploy-package.tar.gz dormed/deploy-package.tar.gz

      - name: Set up SSH key
        # Write the SSH private key content from the secret to a file
        # and set appropriate permissions.
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ORACLE_SSH_KEY }}" > ~/.ssh/id_rsa_oracle
          chmod 600 ~/.ssh/id_rsa_oracle
          echo "SSH_KEY_PATH=~/.ssh/id_rsa_oracle" >> $GITHUB_ENV # Set an environment variable for the key path

      - name: Upload to Oracle VM
        run: |
          echo "=== Uploading build to Oracle VM ==-"
          # Use the newly created SSH key file
          scp -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no deploy-package.tar.gz ${{ secrets.ORACLE_USER }}@${{ secrets.ORACLE_HOST }}:/tmp/

      - name: Deploy on Oracle VM
        run: |
          echo "=== Deploying on Oracle VM ==-"
          # Use the newly created SSH key file
          ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no ${{ secrets.ORACLE_USER }}@${{ secrets.ORACLE_HOST }} << 'EOF'
            set -e
            # Define the base directory where the tarball will be extracted.
            # This is the user's home directory, as per your desired location.
            INSTALL_BASE_DIR="/home/${{ secrets.ORACLE_USER }}"

            # The actual root of the Dormed project on the VM, where manage.py resides.
            # This will be /home/your_user/dormed/ after extraction.
            PROJECT_ROOT_ON_VM="$INSTALL_BASE_DIR/dormed"

            # Set backend, frontend, and venv directories relative to PROJECT_ROOT_ON_VM
            BACKEND_DIR="$PROJECT_ROOT_ON_VM" # manage.py is located here
            FRONTEND_DIR="$PROJECT_ROOT_ON_VM/frontend"
            VENV_DIR="$PROJECT_ROOT_ON_VM/venv" # Venv is at the project root within the tar

            echo "=== Extracting new build ==-"
            # Remove previous deployment of the dormed project itself.
            rm -rf "$PROJECT_ROOT_ON_VM"
            # Ensure the base installation directory exists
            mkdir -p "$INSTALL_BASE_DIR"
            # Extract the tarball into INSTALL_BASE_DIR, which will create INSTALL_BASE_DIR/dormed/...
            tar -xzf /tmp/deploy-package.tar.gz -C "$INSTALL_BASE_DIR"

            # Create the backend .env file on the VM using the GitHub Secret
            echo "Creating backend .env file..."
            echo "${{ secrets.DJANGO_ENV_VARS }}" > "$PROJECT_ROOT_ON_VM"/.env
            chmod 600 "$PROJECT_ROOT_ON_VM"/.env # Set appropriate permissions

            echo "=== Installing backend dependencies ==-"
            # Change to the actual project root on VM for venv activation and pip install
            cd "$PROJECT_ROOT_ON_VM"

            # Recreate venv on the VM if it doesn't exist.
            if [ ! -d "$VENV_DIR" ]; then
              python3 -m venv "$VENV_DIR"
            fi
            source "$VENV_DIR"/bin/activate # Activate from the project root's venv.

            # Upgrade pip, setuptools, and wheel first
            echo "Upgrading pip, setuptools, and wheel..."
            pip install --upgrade pip setuptools wheel

            pip install -r "$PROJECT_ROOT_ON_VM"/requirements.txt # requirements.txt is at project root.

            # Load Django environment variables from the .env file in the root
            if [ -f "$PROJECT_ROOT_ON_VM"/.env ]; then
              echo "Sourcing backend .env file..."
              source "$PROJECT_ROOT_ON_VM"/.env
            else
              echo "Warning: Backend .env file not found at $PROJECT_ROOT_ON_VM/.env"
            fi

            # Now that we're in PROJECT_ROOT_ON_VM (which is also BACKEND_DIR),
            # manage.py commands can be run directly.
            python manage.py migrate
            python manage.py collectstatic --noinput
            deactivate

            echo "=== Restarting Gunicorn ==-"
            sudo systemctl restart gunicorn
          EOF
