name: Build and deploy Dormed Clinic app from local self-hosted runner

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: self-hosted   # This will run on your local machine
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Create Python virtual environment
        # Create the venv in the root of the repository.
        run: |
          python -m venv venv

      - name: Install Python dependencies
        # Activate the venv from the root and install requirements.txt (which is also in the root).
        run: |
          source venv/bin/activate
          pip install -r requirements.txt

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Set up Frontend .env (for React build)
        # Create the .env file in the frontend directory from a GitHub secret.
        # This makes environment variables available during the React build process.
        # Ensure your React environment variables are prefixed with REACT_APP_ (e.g., REACT_APP_API_URL).
        run: |
          echo "${{ secrets.FRONTEND_ENV_VARS }}" > frontend/.env

      - name: Build React frontend
        # Navigate into the 'frontend' directory for npm commands.
        run: |
          cd frontend
          npm install
          npm run build

      - name: Prepare deployment package
        # Create a tarball of the entire checked-out project directory ('.'),
        # excluding the virtual environment and node_modules folders.
        # The tarball 'deploy-package.tar.gz' will be created at the root of the workspace.
        run: |
          tar --exclude=./venv \
              --exclude=./node_modules \
              --exclude=./frontend/node_modules \
              -czf deploy-package.tar.gz .

      - name: Upload deployment artifact
        uses: actions/upload-artifact@v3
        with:
          name: dormed-deploy-package # Name of the artifact to be downloaded later
          path: deploy-package.tar.gz  # Path to the artifact within the workspace

  deploy:
    runs-on: self-hosted
    needs: build # This job will only run after the 'build' job has completed successfully
    steps:
      - name: Download deployment artifact
        uses: actions/download-artifact@v3
        with:
          name: dormed-deploy-package # Downloads the artifact to the current working directory

      - name: Set up SSH key
        # Write the SSH private key content from the secret to a file
        # and set appropriate permissions.
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ORACLE_SSH_KEY }}" > ~/.ssh/id_rsa_oracle
          chmod 600 ~/.ssh/id_rsa_oracle
          # Set an environment variable for the key path, making it available for subsequent steps
          echo "SSH_KEY_PATH=~/.ssh/id_rsa_oracle" >> $GITHUB_ENV

      - name: Upload to Oracle VM
        run: |
          echo "=== Uploading build to Oracle VM ==="
          # Use the newly created SSH key file to SCP the tarball to the VM's /tmp directory
          scp -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no deploy-package.tar.gz ${{ secrets.ORACLE_USER }}@${{ secrets.ORACLE_HOST }}:/tmp/

      - name: Deploy on Oracle VM
        run: |
          echo "=== Deploying on Oracle VM ==="
          # Connect to the Oracle VM via SSH and execute deployment commands
          ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no ${{ secrets.ORACLE_USER }}@${{ secrets.ORACLE_HOST }} << 'EOF'
            set -e # Exit immediately if a command exits with a non-zero status.

            # Define the base directory where the tarball will be extracted.
            # This is the user's home directory, as per your desired location.
            INSTALL_BASE_DIR="/home/${{ secrets.ORACLE_USER }}"

            # The actual root of the Dormed project on the VM after extraction.
            # Since the tarball now contains the project contents directly (not a 'dormed/' folder),
            # the project root will be the install base directory.
            PROJECT_ROOT_ON_VM="$INSTALL_BASE_DIR"

            # Set backend, frontend, and venv directories relative to PROJECT_ROOT_ON_VM
            BACKEND_DIR="$PROJECT_ROOT_ON_VM" # manage.py is located here
            FRONTEND_DIR="$PROJECT_ROOT_ON_VM/frontend"
            VENV_DIR="$PROJECT_ROOT_ON_VM/venv" # Venv is at the project root within the tar

            echo "=== Extracting new build ==="
            # Remove previous deployment of the dormed project by clearing the target directory
            rm -rf "$PROJECT_BASE_DIR"/* # This should be PROJECT_ROOT_ON_VM instead, if we want to remove existing files within it
            # A safer way to clean up if the directory is `INSTALL_BASE_DIR/dormed`
            # For this new tarball strategy, simply remove contents of INSTALL_BASE_DIR or ensure it's empty
            mkdir -p "$INSTALL_BASE_DIR" # Ensure the base installation directory exists
            # Extract the tarball into INSTALL_BASE_DIR. The tarball contains the contents directly.
            tar -xzf /tmp/deploy-package.tar.gz -C "$INSTALL_BASE_DIR"

            # Create the backend .env file on the VM using the GitHub Secret
            echo "Creating backend .env file..."
            echo "${{ secrets.DJANGO_ENV_VARS }}" > "$PROJECT_ROOT_ON_VM"/.env
            chmod 600 "$PROJECT_ROOT_ON_VM"/.env # Set appropriate permissions

            echo "=== Installing backend dependencies ==="
            # Change to the actual project root on VM for venv activation and pip install
            cd "$PROJECT_ROOT_ON_VM"

            # Recreate venv on the VM if it doesn't exist.
            if [ ! -d "$VENV_DIR" ]; then
              python3 -m venv "$VENV_DIR"
            fi
            source "$VENV_DIR"/bin/activate # Activate from the project root's venv.

            # Upgrade pip, setuptools, and wheel first
            echo "Upgrading pip, setuptools, and wheel..."
            pip install --upgrade pip setuptools wheel

            pip install -r "$PROJECT_ROOT_ON_VM"/requirements.txt # requirements.txt is at project root.

            # Load Django environment variables from the .env file in the root
            if [ -f "$PROJECT_ROOT_ON_VM"/.env ]; then
              echo "Sourcing backend .env file..."
              source "$PROJECT_ROOT_ON_VM"/.env
            else
              echo "Warning: Backend .env file not found at $PROJECT_ROOT_ON_VM/.env"
            fi

            # Now that we're in PROJECT_ROOT_ON_VM (which is also BACKEND_DIR),
            # manage.py commands can be run directly.
            python manage.py migrate
            deactivate

            echo "=== Restarting Gunicorn ==="
            sudo systemctl restart dormed
            rm /tmp/deploy-package.tar.gz # Clean up the tarball after deployment
          EOF
