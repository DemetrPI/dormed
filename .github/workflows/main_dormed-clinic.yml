name: Build and deploy Dormed Clinic app from local self-hosted runner

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: self-hosted   # This will run on your local machine

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Create Python virtual environment
        # Create the venv in the root of the repository.
        run: |
          python -m venv venv

      - name: Install Python dependencies
        # Activate the venv from the root and install requirements.txt (which is also in the root).
        run: |
          source venv/bin/activate
          pip install -r requirements.txt

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Set up Frontend .env (for React build)
        # Create the .env file in the frontend directory from a GitHub secret.
        # This makes environment variables available during the React build process.
        # Ensure your React environment variables are prefixed with REACT_APP_ (e.g., REACT_APP_API_URL).
        run: |
          echo "${{ secrets.FRONTEND_ENV_VARS }}" > frontend/.env
          # For security, you might want to remove this file after the build if it contains very sensitive info
          # but usually, the compiled JS is what contains the embedded vars.


      - name: Build React frontend
        # Navigate into the 'frontend' directory for npm commands.
        run: |
          cd frontend
          npm install
          npm run build

      - name: Prepare deployment package
        # Create the tarball from the parent directory to avoid "file changed" errors.
        # This will archive the 'dormed' directory itself, excluding specified folders.
        run: |
          cd .. # Move up one level to the _work directory
          tar --exclude=dormed/venv \
              --exclude=dormed/node_modules \
              --exclude=dormed/frontend/node_modules \
              -czf dormed-deploy-package.tar.gz dormed/
          # Move the created tarball back into the original working directory
          mv dormed-deploy-package.tar.gz dormed/deploy-package.tar.gz

      - name: Set up SSH key
        # Write the SSH private key content from the secret to a file
        # and set appropriate permissions.
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ORACLE_SSH_KEY }}" > ~/.ssh/id_rsa_oracle
          chmod 600 ~/.ssh/id_rsa_oracle
          echo "SSH_KEY_PATH=~/.ssh/id_rsa_oracle" >> $GITHUB_ENV # Set an environment variable for the key path    

      - name: Upload to Oracle VM
        run: |
          echo "=== Uploading build to Oracle VM ==="
          # Use the newly created SSH key file
          scp -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no deploy-package.tar.gz ${{ secrets.ORACLE_USER }}@${{ secrets.ORACLE_HOST }}:/tmp/

      - name: Deploy on Oracle VM
        run: |
          echo "=== Deploying on Oracle VM ==="
          # Use the newly created SSH key file
          ssh -i "$SSH_KEY_PATH" -o StrictHostKeyChecking=no ${{ secrets.ORACLE_USER }}@${{ secrets.ORACLE_HOST }} << 'EOF'
            set -e
            # Corrected: Use the explicit username from the secret to define PROJECT_DIR
            PROJECT_DIR=/home/${{ secrets.ORACLE_USER }}/app
            # The tarball contains a 'dormed/' directory at its root, so the actual
            # project root on the VM will be nested: /home/${USER}/app/dormed
            PROJECT_ROOT_ON_VM=$PROJECT_DIR/dormed

            BACKEND_DIR=$PROJECT_ROOT_ON_VM/dormed_main
            FRONTEND_DIR=$PROJECT_ROOT_ON_VM/frontend
            VENV_DIR=$PROJECT_ROOT_ON_VM/venv # Venv is at the project root within the tar

            echo "=== Extracting new build ==="
            # Remove previous deployment and create a clean project directory
            rm -rf "$PROJECT_DIR"
            mkdir -p "$PROJECT_DIR"
            # Extract the tarball into "$PROJECT_DIR", which will create "$PROJECT_DIR"/dormed/...
            tar -xzf /tmp/deploy-package.tar.gz -C "$PROJECT_DIR"

            # Create the backend .env file on the VM using the GitHub Secret
            echo "Creating backend .env file..."
            echo "${{ secrets.DJANGO_ENV_VARS }}" > "$PROJECT_ROOT_ON_VM"/.env
            chmod 600 "$PROJECT_ROOT_ON_VM"/.env # Set appropriate permissions

            echo "=== Installing backend dependencies ==="
            # Change to the actual project root on VM
            cd "$PROJECT_ROOT_ON_VM"

            # Recreate venv on the VM if it doesn't exist.
            if [ ! -d "$VENV_DIR" ]; then
              python3 -m venv "$VENV_DIR"
            fi
            source "$VENV_DIR"/bin/activate # Activate from the project root's venv.

            # --- FIX: Upgrade pip, setuptools, and wheel first ---
            echo "Upgrading pip, setuptools, and wheel..."
            pip install --upgrade pip setuptools wheel

            pip install -r "$PROJECT_ROOT_ON_VM"/requirements.txt # requirements.txt is at project root.

            # Load Django environment variables from the .env file in the root
            if [ -f "$PROJECT_ROOT_ON_VM"/.env ]; then
              echo "Sourcing backend .env file..."
              source "$PROJECT_ROOT_ON_VM"/.env
            else
              echo "Warning: Backend .env file not found at $PROJECT_ROOT_ON_VM/.env"
            fi

            # --- FIX: Navigate to backend directory *before* running manage.py commands ---
            cd "$BACKEND_DIR"
            python manage.py migrate
            python manage.py collectstatic --noinput
            deactivate

            echo "=== Restarting Gunicorn ==="
            # Gunicorn should be configured to pick up environment variables,
            # either directly from the system or from the sourced .env file if it's restarted.
            sudo systemctl restart gunicorn
          EOF